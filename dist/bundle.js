(()=>{"use strict";const t=class{constructor(t,i,s,e){this.name=t,this.attack=i,this.durability=s,this.baseDurability=s,this.range=e}takeDamage(t){this.durability-=t,this.durability<0&&(this.durability=0)}getDamage(){return this.durability<=0?0:this.durability/this.baseDurability*100>=30?this.attack:Math.floor(this.attack/2)}isBroken(){return 0===this.durability}},i=class extends t{constructor(){super("Рука",1,1/0,1)}},s=class extends t{constructor(){super("Нож",5,300,1)}},e=class{constructor(t,s){this.life=100,this.magic=20,this.speed=1,this.attack=10,this.agility=5,this.luck=10,this.description="Игрок",this.weapon=new i,this.position=t,this.name=s,this.baseLife=this.life,this.baseMagic=this.magic}getLuck(){return(Math.floor(101*Math.random())+this.luck)/100}getDamage(t){const i=this.weapon.getDamage();return t>this.weapon.range?0:(this.attack+i)*this.getLuck()/t}takeDamage(t){this.life-=t,console.log(`${this.name} получил ${t} урона`),this.life<0&&(this.life=0,console.log(`${this.name} достигает нулевой отметки здоровья`))}isDead(){return 0===this.life}moveLeft(t){const i=Math.min(t,this.speed);this.position-=i}moveRight(t){const i=Math.min(t,this.speed);this.position+=i}isAttackBlocked(){return this.getLuck()>(100-this.luck)/100}dodged(){return this.getLuck()>(100-this.agility-3*this.speed)/100}takeAttack(t){if(this.isAttackBlocked())return this.weapon.takeDamage(t),void console.log(`${this.name} заблокировал атаку, урон по оружию: ${t}`);this.dodged()?console.log(`${this.name} уклонился от атаки`):this.takeDamage(t)}checkWeapon(){this.weapon.isBroken()&&(this.weapon instanceof s?(console.log(`${this.name} теряет нож и остается с голыми руками`),this.weapon=new i):this.weapon=new s)}tryAttack(t){let i=0,s=0;if(console.log(`${this.name} (клетка ${this.position}) пробует атаковать ${t.name} (клетка ${t.position})`),this.position===t.position)t.moveRight(1),console.log(`${t.name} отлетает на позицию ${t.position} и получит удвоенный урон от ${this.name}`),i=this.getDamage(1),i*=2;else{if(s=Math.abs(this.position-t.position),s>this.weapon.range)return void console.log(`${this.name} с радиусом атаки ${this.weapon.range} не достаёт до ${t.name} на расстоянии ${s}`);i=this.getDamage(s)}console.log(`рассчитан урон: ${i}`),console.log(`${this.name} атакует ${t.name} на ${i} урона`),this.weapon.takeDamage(10*this.getLuck()),t.takeAttack(i),this.checkWeapon(),t.checkWeapon()}chooseEnemy(t){let i=t.filter((t=>t!==this&&!t.isDead()));if(0===i.length)return null;let s=i[0];for(let t=1;t<i.length;t++)i[t].life<s.life&&(s=i[t]);return s}moveToEnemy(t){if(t&&!t.isDead())if(this.position-t.position<-1){let i=Math.min(t.position-this.position-1,this.speed);console.log(`${this.name} (${this.position}) движется вправо к ${t.name} (${t.position})  на ${i}`),this.moveRight(i)}else if(this.position-t.position>1){let i=Math.min(this.position-t.position-1,this.speed);console.log(`${this.name} (${this.position}) движется влево к ${t.name} (${t.position}) на ${i}`),this.moveLeft(i)}else console.log(`${this.name} (${this.position}) уже рядом с ${t.name} (${t.position})`);else console.log(`${this.name} не может двигаться к мёртвому врагу`)}turn(t){console.log(`\nХодит ${this.name} (уровень здоровья ${this.life})`);const i=this.chooseEnemy(t);i?(console.log(`Выбран противник ${i.name} (уровень здоровья ${i.life})`),this.moveToEnemy(i),this.tryAttack(i),i.isDead()&&console.log(`${i.name} пал в бою после атаки ${this.name}`)):console.log(`${this.name} не нашёл врагов для атаки`)}},a=class extends t{constructor(){super("Меч",25,500,1)}},o=class extends e{constructor(t,i){super(t,i),this.life=120,this.attack=10,this.speed=2,this.weapon=new a,this.description="Воин",this.baseLife=this.life}takeDamage(t){let i=this.life/this.baseLife*100,s=this.getLuck();if(i<50&&s>.8)if(this.magic>t)this.magic-=t;else{const i=t-this.magic;this.magic=0,this.life-=i}else super.takeDamage(t);this.life<0&&(this.life=0)}},h=class extends t{constructor(){super("Лук",10,200,3)}},n=class extends e{constructor(t,i){super(t,i),this.life=80,this.magic=35,this.attack=5,this.agility=10,this.weapon=new h,this.description="Лучник",this.baseLife=this.life,this.baseMagic=this.magic}getDamage(t){const i=this.weapon.getDamage(),s=this.weapon.range;return t>s?0:(this.attack+i)*this.getLuck()*t/s}},c=class extends t{constructor(){super("Посох",8,300,2)}},l=class extends e{constructor(t,i){super(t,i),this.life=70,this.magic=100,this.attack=5,this.agility=8,this.weapon=new c,this.description="Маг",this.baseLife=this.life,this.baseMagic=this.magic}takeDamage(t){this.magic/this.baseMagic*100>50&&(t/=2,this.magic-=12,this.magic<0&&(this.magic=0)),super.takeDamage(t)}},r=class extends a{constructor(){super(),this.name="Секира",this.attack=27,this.durability=800,this.baseDurability=this.durability}},g=class extends h{constructor(){super(),this.name="Длинный лук",this.attack=15,this.range=4}},m=class extends c{constructor(){super(),this.name="Посох Бури",this.attack=10,this.range=3}};console.log("Index module loaded. Hello world!"),console.log("Creating warrior...");let u=new o(0,"Алёша Попович");console.log("Warrior created");let p=new n(6,"Леголас"),d=new l(4,"Гендальф"),f=new class extends l{constructor(t,i){super(t,i),this.description="Демиург",this.weapon=new m,this.life=80,this.magic=120,this.attack=6,this.luck=12,this.baseLife=this.life,this.baseMagic=this.magic}getDamage(t){return this.magic>0&&this.getLuck()>.6?1.5*super.getDamage(t):super.getDamage(t)}}(8,"Истас"),k=new class extends o{constructor(t,i){super(t,i),this.description="Гном",this.life=130,this.attack=15,this.luck=20,this.weapon=new r,this.baseLife=this.life,this.baseMagic=this.magic,this.timesDamaged=0}takeDamage(t){this.timesDamaged++,this.getLuck()>.5&&timesDamaged%6==0&&(t/=2),super.takeDamage(t)}}(11,"Гримли"),$=new class extends n{constructor(t,i){super(t,i),this.weapon=new g,this.description="Арбалетчик",this.life=85,this.attack=8,this.agility=20,this.luck=15,this.baseLife=this.life,this.baseMagic=this.magic}}(13,"Лукарий");console.log("Characters were created"),function(t){for(;t.filter((t=>!t.isDead())).length>1;)for(let i of t)i.isDead()||i.turn(t);const i=t.find((t=>!t.isDead()));console.log(`Победитель: ${i.name}, оставшаяся жизнь: ${i.life}`)}([u,p,d,f,k,$])})();
//# sourceMappingURL=bundle.js.map